---
title: 浅谈并发与并行
date: 2018-12-14 08:52:29
tags:
  - 并发
  - 并行
categories: 
  - 程序员的自我修养
---
首先看一下一个很恰当的比喻：  
>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。  
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。  
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。  
>**并发**的关键是你有**处理多个任务的能力**，不一定要同时。并行的关键是你有**同时**处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。（来自知乎，作者：之乎用户，[链接](https://www.zhihu.com/question/33515481/answer/58849148)）
<!-- more -->
再看一眼权威一点的解释：
>如果某个系统支持两个或者多个动作（Action）**同时存在**，那么这个系统就是一个**并发系统**。如果某个系统支持两个或者多个动作**同时执行**，那么这个系统就是一个**并行系统**。并发系统与并行系统这两个定义之间的关键差异在于**存在**这个词。  
在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。  
我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。摘自：《并发的艺术》 — 〔美〕布雷谢斯。

对于这个问题，我自己也尝试写过一些答案，不过在仔细斟酌之后还是选择只留下这两段前辈写的话，一个清新脱俗简单易懂，一个言之凿凿令人信服。

结合之前写的同步异步、阻塞非阻塞，我们可以看一个比较生动的例子：
假设我们要做烧开水，举杠铃100下， 洗衣服这3件事情。
```
烧开水：准备烧开水（1分钟）， 等开水烧开（8分钟） , 关掉烧水机（1分钟）  
举杠铃100下：举杠铃100下（10分钟）  
洗衣服：准备洗衣服（1分钟）， 等衣服洗完（5分钟），关掉洗衣机（1分钟）
```
## 单核处理器
* 同步阻塞（非并发）  
>事情步骤安排：烧水：准备烧开水（1分钟）， 等开水烧开（8分钟） , 关掉烧水机（1分钟）；举杠铃100下：举杠铃100下（10分钟）；洗衣服：准备洗衣服（1分钟）， 等衣服洗完（5分钟），关掉洗衣机（1分钟）  
>>`做完3件事，花费的时间t = 1+ 8 +1 + 10 + 1+ 5 +1 = 27（分钟）`
* 异步非阻塞（并发）  
在等待事情执行时，我（单核）可以切换出去，做别的事情。  
>事情步骤安排：准备烧开水(1分钟) + 准备洗衣服(1分钟) + 举50下杠铃 (5分钟)+ 关洗衣机（1分钟） + 举杠铃20下（2分钟）+ 关烧水机（1分钟） + 举30下杠铃(3分钟）
在等待衣服洗完（5分钟）时，我（单核）执行举50下杠铃（5分钟）；在等待水烧开（8分钟）时，我（单核）执行举50下杠铃 (5分钟)+ 关洗衣机（1分钟） + 举杠铃20下（2分钟）。  
>>`做完3件事，花费的时间t = 1 + 1 + 5 + 1 + 2 + 1 + 3 = 14（分钟）`

## 双核处理器
* 异步并行  
>核1：准备烧开水（1分钟）+ 举杠铃50下（5分钟）+ 等待（3分钟）+ 关掉烧水机 （1分钟）  
>核2：准备洗衣服（1分钟）+ 举杠铃50下（5分钟）+ 关掉洗衣机（1分钟） + 等待（3分钟）  
>其中，在等待水烧开（8分钟）时，核1执行举杠铃50下（5分钟），等待（3分钟）；在等待衣服洗完（5分钟）时，核2执行举杠铃50下（5分钟）。  
>>`做完3件事，花费的时间t = 1 + 5 + 3 + 1 = 10（分钟），其中双核都等待了3分钟。`

* 异步非并行
>核1：举杠铃100下（10分钟）  
>核2：准备烧开水（1分钟）+ 准备洗衣服（1分钟）+ 等待（6分钟）+ 关掉烧水机（1分钟）+ 关掉洗衣机（1分钟）  
其中，在等待水烧开（8分钟）时，核2执行准备烧开水（1分钟），准备洗衣服（1分钟），等待（6分钟）；在等待衣服洗完（5分钟）时，核2执行等待（6分钟）。`这里多一句嘴，为什么这里是非并行的？我的理解是，“举杠铃”这一耗时操作在计算机中，是不会一直占用一个cpu核心的，通常cpu只会发号施令告诉这条线程该读写数据了（举杠铃），这个线程则在调用系统IO方法之后等待系统IO读写是否完成的结果的过程中被阻塞，线程所占用的cpu资源立即被释放。所以在本例中，只有在核1发令“举杠铃”的那一刻是并行的，其余时间只有核2在断断续续发号施令，是非并行的，异步主要体现在核1上的线程不会主动等待100下杠铃举完而是进入了休眠，核2上的线程不会主动等待烧开水的结果去洗了衣服，不会主动等待洗衣服的结果进入了休眠，直到这些结果产生时通过往pipe管道写端写入数据来唤醒线程分别占用各自的核心继续工作。`
>>`做完3件事，花费的时间t =1 + 1 + 6 + 1 + 1 = 10（分钟）`

PS：为了更好的描述上述问题，这里我们默认每个核针对上述任务都只能运行一条线程，事实上，支持超线程的单个核心能并行两个线程。

## 多线程
* 单核处理器（真单核不支持超线程） 
>线程1：准备烧开水（1分钟）， 等水烧开（8分钟） , 关掉烧水机（1分钟）  
>线程2：举杠铃100下（10分钟）  
>线程3：准备洗衣服（1分钟）， 等水烧开（5 分钟） , 关掉洗衣机（1分钟）  
真单核并不是只能开一条线程，它能开启很多条线程，但是核心并不能同时运行对多线程上的任务，为了达到资源最大化利用它要在线程上来回切换。

>**CPU最理想的切换方式**：  
线程1：准备烧开水（1分钟）+ sleep 1 + sleep 5 + sleep 1 + sleep 2 + 关开水（1分钟）  
线程2：sleep 1+ sleep 1 + 举杠铃50（5分钟）+ sleep 1 + 举杠铃20（2分钟）+ sleep1 + 举杠铃30下（3分钟）  
线程3：sleep 1 + 准备洗衣服（1分钟）+ sleep 5 + 关洗衣机（1分钟）
![](2.png)
最后使用了14分钟，耗时与异步是一样的，印证了我曾经引用的一句话“异步是目的，多线程是手段”。但要注意，实际在计算机中执行这些流程耗时不一定正好是14分钟，因为线程不会按照我们设想的去跑。如果线程2举杠铃先跑，整个流程的速度就下来了。